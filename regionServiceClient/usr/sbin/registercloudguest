#!/usr/bin/python

# Copyright (c) 2015, SUSE LLC, All rights reserved.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3.0 of the License, or (at your option) any later version.
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
# You should have received a copy of the GNU Lesser General Public
# License along with this library.

"""This script obtains information from the configured region server in the
   cloud environment and uses the information to register the guest with
   the SMT server based on the information provided by the region server.

   The configuration is in ini format and is located in
   /etc/regionserverclnt.cfg"""

import ConfigParser
import base64
import glob
import json
import logging
import os
import pickle
import random
import re
import requests
import stat
import subprocess
import sys
import time
import uuid

import cloudregister.registerutils as utils

from cloudregister import smt
from lxml import etree
from M2Crypto import X509

error_exp = re.compile('^error', re.IGNORECASE)


# ----------------------------------------------------------------------------
def add_region_server_args_to_URL(api, cfg):
    """Add arguments from the instance to the given api URL.
       The arguments are generated by a plugin that must provide the
       generateRegionSrvArgs() function.
    """

    if cfg.has_section('instance'):
        module = None
        if cfg.has_option('instance', 'instanceArgs'):
            module = cfg.get('instance', 'instanceArgs')
        if module and module != 'none':
            try:
                mod = __import__('cloudregister.%s' % module, fromlist=[''])
                regionSrvArgs = '?' + mod.generateRegionSrvArgs()
                logging.info('Region server arguments: %s' % regionSrvArgs)
                api += regionSrvArgs
            except:
                msg = 'Configured instanceArgs module could not be loaded. '
                msg += 'Continuing without additional arguments.'
                logging.warning(msg)

    return api


# ----------------------------------------------------------------------------
def get_config(configFile=None):
    """Read configuration file and return a config object"""
    if not configFile:
        configFile = '/etc/regionserverclnt.cfg'

    cfg = ConfigParser.RawConfigParser()
    try:
        parsed = cfg.read(configFile)
    except:
        print 'Could not parse configuration file %s' % configFile
        type, value, tb = sys.exc_info()
        print value.message
        sys.exit(1)

    if not parsed:
        print 'Error parsing config file: %s' % configFile
        sys.exit(1)

    return cfg


# ----------------------------------------------------------------------------
def get_configured_smt(smt_servers, known_hosts):
    """Check if an entry for the given SMT server exists."""
    for smt in smt_servers:
        smt_ip = smt.get_ip()
        smt_fqdn = smt.get_FQDN()
        for entry in known_hosts:
            if smt_ip in entry and smt_fqdn in entry:
                return smt

    return None


# ----------------------------------------------------------------------------
def get_products():
    products = []
    try:
        cmd = subprocess.Popen(
            ["zypper", "--no-remote", "-x", "products"], stdout=subprocess.PIPE
        )
        product_xml = cmd.communicate()
    except:
        errMsg = 'Could not get product list %s' % cmd[1]
        logging.error(errMsg)
        return

    # Detrmine the base product
    baseProdSet = '/etc/products.d/baseproduct'
    baseprodName = None
    if os.path.islink(baseProdSet):
        baseprod = os.path.realpath(baseProdSet)
        baseprodName = baseprod.split(os.sep)[-1].split('.')[0]
    else:
        errMsg = 'No baseproduct installed system cannot be registerd'
        logging.error(errMsg)
        return

    product_tree = etree.fromstring(str(product_xml[0]))
    for child in product_tree.find("product-list"):
        name = child.attrib['name']
        if name == baseprodName:
            continue
        vers = child.attrib['version']
        arch = child.attrib['arch']
        prod = name + "/" + vers + "/" + arch
        if prod not in products:
            products.append(prod)

    return products


# ----------------------------------------------------------------------------
def is_zypper_running():
    """Check if zypper is running"""
    # Zypper doesn't remove it's pid file, need to consult the process table
    zypper_pid = utils.get_zypper_pid()
    if zypper_pid != '':
        return True

    return False


# ----------------------------------------------------------------------------
# Support custom config file with -f command line option
configFile = None

if '-f' in sys.argv:
    idx = sys.argv.index('-f')
    configFile = sys.argv[idx+1]

force_new_registration = False
if '--force-new' in sys.argv:
    force_new_registration = True

if '--delay' in sys.argv:
    arg_index = sys.argv.index('--delay')
    delay_time = sys.argv[arg_index + 1]
    time.sleep(int(delay_time))

cfg = get_config(configFile)
utils.start_logging()

if force_new_registration:
    logging.info('Forced new registration')

# Proxy setup
proxies = None
proxy = utils.set_proxy()
if proxy:
    http_proxy = os.environ.get('http_proxy')
    https_proxy = os.environ.get('https_proxy')
    proxies = {'http_proxy': http_proxy,
               'https_proxy': https_proxy}
    logging.info('Using proxy settings: %s' % proxies)

# Get the SMT server information from the metadats server or
# one of the configured region servers
response = None
if cfg.has_option('server', 'metadata_server'):
    metadata_url = cfg.get('server', 'metadata_server')
    logging.info(
        'Using metada server "%s" to obtain SMT information' % metadata_url
    )
    try:
        response = requests.get(
            metadata_url,
            timeout=15.0,
            proxies=proxies
        )
        if response.status_code != 200:
            raise Exception(
                'Metadata server returned %s' % response.status_code
            )
    except Exception as e:
        logging.error('=' * 20)
        logging.error(e.message)
        logging.error('Unable to obtain SMT server information, exiting')
        sys.exit(1)
    smt_info = json.loads(response.text)
    expected_entries = ('fingerprint', 'SMTserverIP', 'SMTserverName')
    smt_info_xml = '<regionSMTdata><smtInfo '
    for attr in expected_entries:
        value = smt_info.get(attr)
        if not value:
            logging.error(
                'Metadata server did not supply a vlaue for "%s"' % attr
            )
            logging.error('Cannot proceed, exiting registration code')
            sys.exit(1)
        smt_info_xml += '%s="%s" ' % (attr, value)
    smt_info_xml += '/></regionSMTdata>'
    smtDataRoot = etree.fromstring(smt_info_xml)
else:
    # Get the API to use
    api = cfg.get('server', 'api')
    logging.info('Using API: %s' % api)
    # Add regionserver arguments
    api = add_region_server_args_to_URL(api, cfg)
    # Get the location of the cert files for the region servers
    cert_dir = cfg.get('server', 'certLocation')
    region_servers = cfg.get('server', 'regionsrv').split(',')
    random.shuffle(region_servers)
    for srv in region_servers:
        srvName = srv.strip()
        logging.info('Using region server: %s' % srvName)
        certFile = cert_dir + '/' + srvName + '.pem'
        if not os.path.isfile(certFile):
            logging.info('No cert found: %s skip this server' % certFile)
            continue
        try:
            response = requests.get(
                'https://%s/%s' % (srvName, api),
                verify=certFile,
                timeout=15.0,
                proxies=proxies
            )
            if response.status_code == 200:
                break
            else:
                logging.error('=' * 20)
                logging.error('Server returned: %d' % response.status_code)
                logging.error(response.text)
                logging.error('=' * 20)
        except:
            logging.error('No response from: %s' % srvName)
            if srv == region_servers[-1]:
                logging.error('None of the servers responded')
                logging.error('\tAttempted: %s' % region_servers)
                logging.error('Exiting without registration')
                sys.exit(1)
            continue
    if (not response) or (not response.status_code == 200):
        logging.error('Request not answered by any server, exiting')
        sys.exit(1)
    smtDataRoot = etree.fromstring(response.text)

known_smt_servers = []
smt_count = 1
if not os.path.exists(utils.REGISTRATION_DATA_DIR):
    os.mkdir(utils.REGISTRATION_DATA_DIR)
for child in smtDataRoot:
    smt_server = smt.SMT(child)
    store_file_name = (utils.REGISTRATION_DATA_DIR +
                       utils.AVAILABLE_SMT_SERVER_DATA_FILE_NAME % smt_count)
    utils.store_smt_data(store_file_name, smt_server)
    known_smt_servers.append(smt_server)
    smt_count += 1

# This is a forced re-registration clear out all existing data
if force_new_registration:
    if is_zypper_running():
        msg = 'zypper is running: Registration with the update '
        msg += 'infrastructure is only possible if zypper is not running.\n'
        msg += 'Please re-run the force registration process after zypper '
        msg += 'has completed'
        print msg
        sys.exit(1)
    utils.remove_registration_data(known_smt_servers)

# Check if we have some kind of configuartion
known_hosts = open('/etc/hosts', 'r').readlines()
configured_smt_server = get_configured_smt(known_smt_servers, known_hosts)
if configured_smt_server:
    if utils.is_registered(configured_smt_server):
        alive = configured_smt_server.is_responsive()
        if alive:
            msg = 'Instance is registered, and SMT server is reachable, '
            msg += 'nothing to do'
            logging.info(msg)
            sys.exit(0)
        else:
            # The configured server is not resposive, lets check if we can
            # find another server
            new_target = utils.find_equivalent_smt_server(
                configured_smt_server,
                known_smt_servers)
            if new_target:
                msg = 'Configured SMT unresponsive, switching to equivalent '
                msg += 'SMT server with ip %s' % new_target.get_ip()
                utils.replace_hosts_entry(configured_smt_server, new_target)
            else:
                force_new_registration = True
                msg = 'Configured SMT unresponsive, could not find '
                msg += 'equivalent SMT, forcing new registration'
                logging.info(msg)
                utils.remove_registration_data(known_smt_servers)
    else:
        # We are in a weird state with remnants in /etc/hosts but
        # no registration
        utils.remove_registration_data(known_smt_servers)

# Figure out which server is responsive and use it as registration target
registration_target = None
tested_smt_servers = []
for smt in known_smt_servers:
    smt_ip = smt.get_ip()
    tested_smt_servers.append(smt_ip)
    alive = smt.is_responsive()
    if alive:
        registration_target = smt
        # Use the first server that responds
        break

if not registration_target:
    logging.error('None response from: %s' % tested_smt_servers)
    sys.exit(1)

# Add the target SMT server to the hosts file
utils.add_hosts_entry(registration_target)

# Create location to store data if it does not exist
if not os.path.exists(utils.REGISTRATION_DATA_DIR):
    os.system('mkdir -p %s' % utils.REGISTRATION_DATA_DIR)

# Write the data of the current target server
utils.set_as_current_smt(registration_target)

# Check if we need to send along any instance data
instance_data_filepath = utils.REGISTRATION_DATA_DIR + str(uuid.uuid4())
if cfg.has_section('instance'):
    if cfg.has_option('instance', 'dataProvider'):
        instance_data_cmd = cfg.get('instance', 'dataProvider')
        cmd = instance_data_cmd.split()[0]
        if cmd != 'none':
            if cmd[0] != '/':
                try:
                    p = subprocess.Popen(
                        ['which %s' % cmd],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        close_fds=True
                    )
                except:
                    errMsg = 'Could not find configured dataProvider: %s' % cmd
                    logging.error(errMsg)
            if os.access(cmd, os.X_OK):
                os.system("%s > %s" % (instance_data_cmd,
                                       instance_data_filepath))
            else:
                msg = 'Configured dataProvider "%s" is not executable' % cmd
                logging.error(msg)

register11 = '/usr/lib/suseRegister/bin/clientSetup4SMT.sh'
register12 = '/usr/sbin/SUSEConnect'
if (os.path.exists(register11) and os.access(register11, os.X_OK)):
    base_registered = False
    failed_smts = []
    while not base_registered:
        cmd = register11
        cmd += ' --host %s ' % registration_target.get_FQDN()
        cmd += '--fingerprint %s ' % registration_target.get_fingerprint()
        cmd += '--yes '

        if os.path.exists(instance_data_filepath):
            cmd += '--regdata %s' % instance_data_filepath

        if force_new_registration:
            cmd += ' > /dev/null 2>&1'

        logging.info('Registration: %s' % cmd)
        res = os.system(cmd)

        if res:
            failed_smts.append(registration_target.get_ip())
            if len(failed_smts) == len(known_smt_servers):
                logging.error('Registration failed')
                sys.exit(1)
            for smt in known_smt_servers:
                if (
                        smt.get_ip() != registration_target.get_ip() and
                        smt.get_ip() not in failed_smts
                ):
                    error_msg = 'Registration with %s failed. Trying %s'
                    logging.error(
                        error_msg % (
                            registration_target.get_ip(),
                            smt.get_ip()
                        )
                    )
                    utils.remove_registration_data([registration_target])
                    utils.add_hosts_entry(smt)
                    registration_target = smt
                    break
        else:
            base_registered = True

    # registration was successful, let's check if the repos do
    # really exist and if not complete the registration by calling
    # suse_register with the restore-repos option
    reposExist = utils.has_repos(registration_target.get_FQDN())
    if not reposExist:
        cmd = "suse_register --restore-repos"
        res = os.system(cmd)
        if res:
            logging.info('Repositories were not restored')
    
    utils.enable_repository('SLE11-Public-Cloud-Module')

elif (os.path.exists(register12) and os.access(register12, os.X_OK)):
    # get product list
    products = get_products()
    if products is None:
        sys.exit(1)

    if not utils.import_smt_cert(registration_target):
        logging.error('SMT certificate import failed')
        sys.exit(1)

    # Register the base product first
    base_registered = False
    failed_smts = []
    while not base_registered:
        cmd = [register12, '--url']
        cmd.append('https://%s' % registration_target.get_FQDN())
        if os.path.exists(instance_data_filepath):
            cmd.append('--instance-data')
            cmd.append(instance_data_filepath)
        p = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        res = p.communicate()
        for entry in res:
            if error_exp.match(entry):
                failed_smts.append(registration_target.get_ip())
                if len(failed_smts) == len(known_smt_servers):
                    logging.error('Baseproduct registration failed')
                    logging.error('\t%s' % entry)
                    sys.exit(1)
                for smt in known_smt_servers:
                    if (
                            smt.get_ip() != registration_target.get_ip() and
                            smt.get_ip() not in failed_smts
                    ):
                        error_msg = 'Registration with %s failed. Trying %s'
                        logging.error(
                            error_msg % (
                                registration_target.get_ip(),
                                smt.get_ip()
                            )
                        )
                        utils.remove_registration_data([registration_target])
                        utils.add_hosts_entry(smt)
                        registration_target = smt
                        break
                break
        else:
            base_registered = True

    for product in products:
        cmd = [
            register12,
            '--url',
            'https://%s' % registration_target.get_FQDN(),
            '--product',
            product]
        if os.path.exists(instance_data_filepath):
            cmd.append('--instance-data')
            cmd.append(instance_data_filepath)

        logging.info('Registration: %s' % ' '.join(cmd))
        p = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        res = p.communicate()

        for entry in res:
            if 'Error:' in entry:
                logging.error('\tRegistration failed: %s' % entry)
else:
    logging.error('No registration executable found')
    sys.exit(1)

if os.path.exists(instance_data_filepath):
    os.unlink(instance_data_filepath)
